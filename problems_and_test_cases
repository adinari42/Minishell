/***************
not working:
****************/
cat infile | cat			(requires me to hit enter to get the prompt back. Stays this way until minishell is closed. same for every command with a pipe, I think?)
export a=1 | cat 			(does not behave like bash. export variable is okay now, but bash blocks/'hangs', minishell does not)

many many leaks
echo $?						(leaks? Not sure)
dprintf is a forbidden function
perror is a forbidden function
""							(should output "command not found")
"" | "" | "" ""				(doesn't crash, but bash outputs "command not found", minishell doesn't output anything)
Try 'ctrl-C' after running a blocking command like cat without arguments or grep “something“. : looks good, but exit code is not 130
exit code of 'Ctrl-\' after running a blocking command like cat should be 131
none of the builtins properly handle exit codes, they need to go into $?

/***************
to check:
****************/
do all the builtins work when the input starts with spaces?
maybe put skip_spaces at the start of tokenizing function
minishell sometimes 'hangs' and does not display the next prompt after input. Seems to happen after an unclose quotes error, but I'm not sure.
occasional segfault on starting - something in pipes.c when elements get deleted?
check if heredoc is still working
clean up the Makefile, make sure everything compiles when brew is not installed

/***************
working atm:
****************/
cat main.c					
echo foo$USER				
echo $?						(does not output '0' if it is the first command being executed, instead outputs some random value)
export foo=3			- still ok
echo "foo" > bar
< infile cat
grep -Hirn "parse error" .	(quotes problem, outputs lines that don't contain parse error)
< infile | cat
cat infile | cat			(requires me to hit enter to get the prompt back. same for every command with a pipe, I think?)
echo "foo" | echo "bar"
echo "'$USER'"				(should output adinari or slakner, but it just outputs a single ' (single quote))
echo '"$USER"'				(should output "$USER")
echo "foo"   "foo"
echo lllllll          kkkkkkkk
echo "'"
ctrl-\ in a prompt after you wrote some stuff (should not do anything : pressing should not make cursor jump to beginning of prompt line)
echo $foo					(segfaults)
[input of spaces only]
echo $L						(outputs the value of $LaunchInstanceID, the first variable starting with 'L')
exit 7 :    exit does not exit with the exit code given as argument, using echo $? after exiting must show 7
exit aaasdasdasdas : must exit with 255 failure code , and print “minishell: exit: asdasdasdas: numeric argument required”
echo "foo" |||				(segfaults)
|||							(segfaults)
|							(does not throw an error)
| cat						(segfaults)